/* automatically generated by rust-bindgen */

pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
pub const PRId16: &'static [u8; 3usize] = b"hd\0";
pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\0";
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101304;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const JACK_MAX_FRAMES: u32 = 4294967295;
pub const JACK_LOAD_INIT_LIMIT: u32 = 1024;
pub const JACK_DEFAULT_AUDIO_TYPE: &'static [u8; 24usize] = b"32 bit float mono audio\0";
pub const JACK_DEFAULT_MIDI_TYPE: &'static [u8; 15usize] = b"8 bit raw midi\0";
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type wchar_t = __darwin_wchar_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    #[link_name = "\u{1}_imaxabs"]
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_imaxdiv"]
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    #[link_name = "\u{1}_strtoimax"]
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    #[link_name = "\u{1}_strtoumax"]
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    #[link_name = "\u{1}_wcstoimax"]
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    #[link_name = "\u{1}_wcstoumax"]
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).__opaque as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__opaque)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_sched_yield"]
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sched_get_priority_min"]
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sched_get_priority_max"]
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_getdate_err"]
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_asctime"]
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_clock"]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[link_name = "\u{1}_ctime"]
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_difftime"]
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_getdate"]
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_gmtime"]
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_localtime"]
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_mktime"]
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_strftime"]
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_strptime"]
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_time"]
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_tzset"]
    pub fn tzset();
}
extern "C" {
    #[link_name = "\u{1}_asctime_r"]
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ctime_r"]
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gmtime_r"]
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_localtime_r"]
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_posix2time"]
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_tzsetwall"]
    pub fn tzsetwall();
}
extern "C" {
    #[link_name = "\u{1}_time2posix"]
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_timelocal"]
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_timegm"]
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_nanosleep"]
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = u32;
extern "C" {
    #[link_name = "\u{1}_clock_getres"]
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_clock_gettime"]
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_clock_gettime_nsec_np"]
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    #[link_name = "\u{1}_clock_settime"]
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_1 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_1 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_1 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_1 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_1 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = u32;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_qos_class_self"]
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    #[link_name = "\u{1}_qos_class_main"]
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_set_qos_class_np"]
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_get_qos_class_np"]
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_set_qos_class_self_np"]
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_qos_class_np"]
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    #[link_name = "\u{1}_pthread_override_qos_class_start_np"]
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_override_qos_class_end_np"]
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
pub type sigset_t = __darwin_sigset_t;
extern "C" {
    #[link_name = "\u{1}_pthread_atfork"]
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_destroy"]
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getdetachstate"]
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getguardsize"]
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getinheritsched"]
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getschedparam"]
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getschedpolicy"]
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getscope"]
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstack"]
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstackaddr"]
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstacksize"]
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_init"]
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setdetachstate"]
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setguardsize"]
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setinheritsched"]
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setschedparam"]
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setschedpolicy"]
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setscope"]
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstack"]
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstackaddr"]
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstacksize"]
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cancel"]
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_broadcast"]
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_destroy"]
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_init"]
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_signal"]
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_timedwait"]
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_wait"]
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_destroy"]
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_init"]
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_getpshared"]
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_setpshared"]
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_create"]
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_detach"]
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_equal"]
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_exit"]
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_pthread_getconcurrency"]
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getschedparam"]
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getspecific"]
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_pthread_join"]
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_key_create"]
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_key_delete"]
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_destroy"]
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_getprioceiling"]
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_init"]
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_lock"]
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_setprioceiling"]
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_trylock"]
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_unlock"]
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_destroy"]
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getprioceiling"]
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getprotocol"]
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getpshared"]
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_gettype"]
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_init"]
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setprioceiling"]
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setprotocol"]
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setpshared"]
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_settype"]
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_once"]
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_destroy"]
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_init"]
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_rdlock"]
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_tryrdlock"]
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_trywrlock"]
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_wrlock"]
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_unlock"]
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_destroy"]
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_getpshared"]
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_init"]
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_setpshared"]
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_self"]
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setcancelstate"]
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setcanceltype"]
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setconcurrency"]
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setschedparam"]
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setspecific"]
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_testcancel"]
    pub fn pthread_testcancel();
}
extern "C" {
    #[link_name = "\u{1}_pthread_is_threaded_np"]
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_threadid_np"]
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getname_np"]
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setname_np"]
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_main_np"]
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mach_thread_np"]
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_stacksize_np"]
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_stackaddr_np"]
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_signal_thread_np"]
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_timedwait_relative_np"]
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_create_suspended_np"]
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_kill"]
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_from_mach_thread_np"]
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_sigmask"]
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_yield_np"]
    pub fn pthread_yield_np();
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __int32_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type jack_native_thread_t = pthread_t;
pub type jack_uuid_t = u64;
pub type jack_shmsize_t = i32;
pub type jack_nframes_t = u32;
pub type jack_time_t = u64;
pub type jack_intclient_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jack_port {
    _unused: [u8; 0],
}
pub type jack_port_t = _jack_port;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jack_client {
    _unused: [u8; 0],
}
pub type jack_client_t = _jack_client;
pub type jack_port_id_t = u32;
pub type jack_port_type_id_t = u32;
pub const JackOptions_JackNullOption: JackOptions = 0;
pub const JackOptions_JackNoStartServer: JackOptions = 1;
pub const JackOptions_JackUseExactName: JackOptions = 2;
pub const JackOptions_JackServerName: JackOptions = 4;
pub const JackOptions_JackLoadName: JackOptions = 8;
pub const JackOptions_JackLoadInit: JackOptions = 16;
pub const JackOptions_JackSessionID: JackOptions = 32;
pub type JackOptions = u32;
pub use self::JackOptions as jack_options_t;
pub const JackStatus_JackFailure: JackStatus = 1;
pub const JackStatus_JackInvalidOption: JackStatus = 2;
pub const JackStatus_JackNameNotUnique: JackStatus = 4;
pub const JackStatus_JackServerStarted: JackStatus = 8;
pub const JackStatus_JackServerFailed: JackStatus = 16;
pub const JackStatus_JackServerError: JackStatus = 32;
pub const JackStatus_JackNoSuchClient: JackStatus = 64;
pub const JackStatus_JackLoadFailure: JackStatus = 128;
pub const JackStatus_JackInitFailure: JackStatus = 256;
pub const JackStatus_JackShmFailure: JackStatus = 512;
pub const JackStatus_JackVersionError: JackStatus = 1024;
pub const JackStatus_JackBackendError: JackStatus = 2048;
pub const JackStatus_JackClientZombie: JackStatus = 4096;
pub type JackStatus = u32;
pub use self::JackStatus as jack_status_t;
pub const JackLatencyCallbackMode_JackCaptureLatency: JackLatencyCallbackMode = 0;
pub const JackLatencyCallbackMode_JackPlaybackLatency: JackLatencyCallbackMode = 1;
pub type JackLatencyCallbackMode = u32;
pub use self::JackLatencyCallbackMode as jack_latency_callback_mode_t;
pub type JackLatencyCallback = ::std::option::Option<
    unsafe extern "C" fn(mode: jack_latency_callback_mode_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _jack_latency_range {
    pub min: jack_nframes_t,
    pub max: jack_nframes_t,
}
#[test]
fn bindgen_test_layout__jack_latency_range() {
    assert_eq!(
        ::std::mem::size_of::<_jack_latency_range>(),
        8usize,
        concat!("Size of: ", stringify!(_jack_latency_range))
    );
    assert_eq!(
        ::std::mem::align_of::<_jack_latency_range>(),
        1usize,
        concat!("Alignment of ", stringify!(_jack_latency_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_latency_range>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_latency_range),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_latency_range>())).max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_latency_range),
            "::",
            stringify!(max)
        )
    );
}
pub type jack_latency_range_t = _jack_latency_range;
pub type JackProcessCallback = ::std::option::Option<
    unsafe extern "C" fn(
        nframes: jack_nframes_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type JackThreadCallback = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type JackThreadInitCallback =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
pub type JackGraphOrderCallback = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type JackXRunCallback = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type JackBufferSizeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        nframes: jack_nframes_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type JackSampleRateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        nframes: jack_nframes_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type JackPortRegistrationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        port: jack_port_id_t,
        arg1: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type JackClientRegistrationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        arg1: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type JackPortConnectCallback = ::std::option::Option<
    unsafe extern "C" fn(
        a: jack_port_id_t,
        b: jack_port_id_t,
        connect: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type JackPortRenameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        port: jack_port_id_t,
        old_name: *const ::std::os::raw::c_char,
        new_name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type JackFreewheelCallback = ::std::option::Option<
    unsafe extern "C" fn(starting: ::std::os::raw::c_int, arg: *mut ::std::os::raw::c_void),
>;
pub type JackShutdownCallback =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
pub type JackInfoShutdownCallback = ::std::option::Option<
    unsafe extern "C" fn(
        code: jack_status_t,
        reason: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type jack_default_audio_sample_t = f32;
pub const JackPortFlags_JackPortIsInput: JackPortFlags = 1;
pub const JackPortFlags_JackPortIsOutput: JackPortFlags = 2;
pub const JackPortFlags_JackPortIsPhysical: JackPortFlags = 4;
pub const JackPortFlags_JackPortCanMonitor: JackPortFlags = 8;
pub const JackPortFlags_JackPortIsTerminal: JackPortFlags = 16;
pub type JackPortFlags = u32;
pub const jack_transport_state_t_JackTransportStopped: jack_transport_state_t = 0;
pub const jack_transport_state_t_JackTransportRolling: jack_transport_state_t = 1;
pub const jack_transport_state_t_JackTransportLooping: jack_transport_state_t = 2;
pub const jack_transport_state_t_JackTransportStarting: jack_transport_state_t = 3;
pub const jack_transport_state_t_JackTransportNetStarting: jack_transport_state_t = 4;
pub type jack_transport_state_t = u32;
pub type jack_unique_t = u64;
pub const jack_position_bits_t_JackPositionBBT: jack_position_bits_t = 16;
pub const jack_position_bits_t_JackPositionTimecode: jack_position_bits_t = 32;
pub const jack_position_bits_t_JackBBTFrameOffset: jack_position_bits_t = 64;
pub const jack_position_bits_t_JackAudioVideoRatio: jack_position_bits_t = 128;
pub const jack_position_bits_t_JackVideoFrameOffset: jack_position_bits_t = 256;
pub type jack_position_bits_t = u32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _jack_position {
    pub unique_1: jack_unique_t,
    pub usecs: jack_time_t,
    pub frame_rate: jack_nframes_t,
    pub frame: jack_nframes_t,
    pub valid: jack_position_bits_t,
    pub bar: i32,
    pub beat: i32,
    pub tick: i32,
    pub bar_start_tick: f64,
    pub beats_per_bar: f32,
    pub beat_type: f32,
    pub ticks_per_beat: f64,
    pub beats_per_minute: f64,
    pub frame_time: f64,
    pub next_time: f64,
    pub bbt_offset: jack_nframes_t,
    pub audio_frames_per_video_frame: f32,
    pub video_offset: jack_nframes_t,
    pub padding: [i32; 7usize],
    pub unique_2: jack_unique_t,
}
#[test]
fn bindgen_test_layout__jack_position() {
    assert_eq!(
        ::std::mem::size_of::<_jack_position>(),
        136usize,
        concat!("Size of: ", stringify!(_jack_position))
    );
    assert_eq!(
        ::std::mem::align_of::<_jack_position>(),
        1usize,
        concat!("Alignment of ", stringify!(_jack_position))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).unique_1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(unique_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).usecs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(usecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).frame_rate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).frame as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).valid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).bar as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(bar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).beat as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(beat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).tick as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).bar_start_tick as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(bar_start_tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).beats_per_bar as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(beats_per_bar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).beat_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(beat_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).ticks_per_beat as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(ticks_per_beat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).beats_per_minute as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(beats_per_minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).frame_time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(frame_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).next_time as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(next_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).bbt_offset as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(bbt_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_jack_position>())).audio_frames_per_video_frame as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(audio_frames_per_video_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).video_offset as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(video_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).padding as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jack_position>())).unique_2 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_jack_position),
            "::",
            stringify!(unique_2)
        )
    );
}
pub type jack_position_t = _jack_position;
pub type JackSyncCallback = ::std::option::Option<
    unsafe extern "C" fn(
        state: jack_transport_state_t,
        pos: *mut jack_position_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type JackTimebaseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        state: jack_transport_state_t,
        nframes: jack_nframes_t,
        pos: *mut jack_position_t,
        new_pos: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub const jack_transport_bits_t_JackTransportState: jack_transport_bits_t = 1;
pub const jack_transport_bits_t_JackTransportPosition: jack_transport_bits_t = 2;
pub const jack_transport_bits_t_JackTransportLoop: jack_transport_bits_t = 4;
pub const jack_transport_bits_t_JackTransportSMPTE: jack_transport_bits_t = 8;
pub const jack_transport_bits_t_JackTransportBBT: jack_transport_bits_t = 16;
pub type jack_transport_bits_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jack_transport_info_t {
    pub frame_rate: jack_nframes_t,
    pub usecs: jack_time_t,
    pub valid: jack_transport_bits_t,
    pub transport_state: jack_transport_state_t,
    pub frame: jack_nframes_t,
    pub loop_start: jack_nframes_t,
    pub loop_end: jack_nframes_t,
    pub smpte_offset: ::std::os::raw::c_long,
    pub smpte_frame_rate: f32,
    pub bar: ::std::os::raw::c_int,
    pub beat: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub bar_start_tick: f64,
    pub beats_per_bar: f32,
    pub beat_type: f32,
    pub ticks_per_beat: f64,
    pub beats_per_minute: f64,
}
#[test]
fn bindgen_test_layout_jack_transport_info_t() {
    assert_eq!(
        ::std::mem::size_of::<jack_transport_info_t>(),
        96usize,
        concat!("Size of: ", stringify!(jack_transport_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<jack_transport_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(jack_transport_info_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).frame_rate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jack_transport_info_t>())).usecs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(usecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jack_transport_info_t>())).valid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).transport_state as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(transport_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jack_transport_info_t>())).frame as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).loop_start as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(loop_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jack_transport_info_t>())).loop_end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(loop_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).smpte_offset as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(smpte_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).smpte_frame_rate as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(smpte_frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jack_transport_info_t>())).bar as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(bar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jack_transport_info_t>())).beat as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(beat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jack_transport_info_t>())).tick as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).bar_start_tick as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(bar_start_tick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).beats_per_bar as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(beats_per_bar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jack_transport_info_t>())).beat_type as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(beat_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).ticks_per_beat as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(ticks_per_beat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jack_transport_info_t>())).beats_per_minute as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(jack_transport_info_t),
            "::",
            stringify!(beats_per_minute)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_jack_release_timebase"]
    pub fn jack_release_timebase(client: *mut jack_client_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_jack_set_sync_callback"]
    pub fn jack_set_sync_callback(
        client: *mut jack_client_t,
        sync_callback: JackSyncCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_jack_set_sync_timeout"]
    pub fn jack_set_sync_timeout(
        client: *mut jack_client_t,
        timeout: jack_time_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_jack_set_timebase_callback"]
    pub fn jack_set_timebase_callback(
        client: *mut jack_client_t,
        conditional: ::std::os::raw::c_int,
        timebase_callback: JackTimebaseCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_jack_transport_locate"]
    pub fn jack_transport_locate(
        client: *mut jack_client_t,
        frame: jack_nframes_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_jack_transport_query"]
    pub fn jack_transport_query(
        client: *const jack_client_t,
        pos: *mut jack_position_t,
    ) -> jack_transport_state_t;
}
extern "C" {
    #[link_name = "\u{1}_jack_get_current_transport_frame"]
    pub fn jack_get_current_transport_frame(client: *const jack_client_t) -> jack_nframes_t;
}
extern "C" {
    #[link_name = "\u{1}_jack_transport_reposition"]
    pub fn jack_transport_reposition(
        client: *mut jack_client_t,
        pos: *const jack_position_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_jack_transport_start"]
    pub fn jack_transport_start(client: *mut jack_client_t);
}
extern "C" {
    #[link_name = "\u{1}_jack_transport_stop"]
    pub fn jack_transport_stop(client: *mut jack_client_t);
}
extern "C" {
    #[link_name = "\u{1}_jack_get_transport_info"]
    pub fn jack_get_transport_info(client: *mut jack_client_t, tinfo: *mut jack_transport_info_t);
}
extern "C" {
    #[link_name = "\u{1}_jack_set_transport_info"]
    pub fn jack_set_transport_info(client: *mut jack_client_t, tinfo: *mut jack_transport_info_t);
}
extern "C" {
    #[doc = " Call this function to get version of the JACK, in form of several numbers"]
    #[doc = ""]
    #[doc = " @param major_ptr pointer to variable receiving major version of JACK."]
    #[doc = ""]
    #[doc = " @param minor_ptr pointer to variable receiving minor version of JACK."]
    #[doc = ""]
    #[doc = " @param major_ptr pointer to variable receiving micro version of JACK."]
    #[doc = ""]
    #[doc = " @param major_ptr pointer to variable receiving protocol version of JACK."]
    #[doc = ""]
    #[link_name = "\u{1}_jack_get_version"]
    pub fn jack_get_version(
        major_ptr: *mut ::std::os::raw::c_int,
        minor_ptr: *mut ::std::os::raw::c_int,
        micro_ptr: *mut ::std::os::raw::c_int,
        proto_ptr: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Call this function to get version of the JACK, in form of a string"]
    #[doc = ""]
    #[doc = " @return Human readable string describing JACK version being used."]
    #[doc = ""]
    #[link_name = "\u{1}_jack_get_version_string"]
    pub fn jack_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Open an external client session with a JACK server.  This interface"]
    #[doc = " is more complex but more powerful than jack_client_new().  With it,"]
    #[doc = " clients may choose which of several servers to connect, and control"]
    #[doc = " whether and how to start the server automatically, if it was not"]
    #[doc = " already running.  There is also an option for JACK to generate a"]
    #[doc = " unique client name, when necessary."]
    #[doc = ""]
    #[doc = " @param client_name of at most jack_client_name_size() characters."]
    #[doc = " The name scope is local to each server.  Unless forbidden by the"]
    #[doc = " @ref JackUseExactName option, the server will modify this name to"]
    #[doc = " create a unique variant, if needed."]
    #[doc = ""]
    #[doc = " @param options formed by OR-ing together @ref JackOptions bits."]
    #[doc = " Only the @ref JackOpenOptions bits are allowed."]
    #[doc = ""]
    #[doc = " @param status (if non-NULL) an address for JACK to return"]
    #[doc = " information from the open operation.  This status word is formed by"]
    #[doc = " OR-ing together the relevant @ref JackStatus bits."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " <b>Optional parameters:</b> depending on corresponding [@a options"]
    #[doc = " bits] additional parameters may follow @a status (in this order)."]
    #[doc = ""]
    #[doc = " @arg [@ref JackServerName] <em>(char *) server_name</em> selects"]
    #[doc = " from among several possible concurrent server instances.  Server"]
    #[doc = " names are unique to each user.  If unspecified, use \"default\""]
    #[doc = " unless \\$JACK_DEFAULT_SERVER is defined in the process environment."]
    #[doc = ""]
    #[doc = " @return Opaque client handle if successful.  If this is NULL, the"]
    #[doc = " open operation failed, @a *status includes @ref JackFailure and the"]
    #[doc = " caller is not a JACK client."]
    #[link(name = "jack")]
    pub fn jack_client_open(
        client_name: *const ::std::os::raw::c_char,
        options: jack_options_t,
        status: *mut jack_status_t,
        ...
    ) -> *mut jack_client_t;
}
extern "C" {
    #[doc = " \\bold THIS FUNCTION IS DEPRECATED AND SHOULD NOT BE USED IN"]
    #[doc = "  NEW JACK CLIENTS"]
    #[doc = ""]
    #[doc = " @deprecated Please use jack_client_open()."]
    #[link_name = "\u{1}_jack_client_new"]
    pub fn jack_client_new(client_name: *const ::std::os::raw::c_char) -> *mut jack_client_t;
}
extern "C" {
    #[doc = " Disconnects an external client from a JACK server."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_client_close"]
    pub fn jack_client_close(client: *mut jack_client_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the maximum number of characters in a JACK client name"]
    #[doc = " including the final NULL character.  This value is a constant."]
    #[link_name = "\u{1}_jack_client_name_size"]
    pub fn jack_client_name_size() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return pointer to actual client name.  This is useful when @ref"]
    #[doc = " JackUseExactName is not specified on open and @ref"]
    #[doc = " JackNameNotUnique status was returned.  In that case, the actual"]
    #[doc = " name will differ from the @a client_name requested."]
    #[link_name = "\u{1}_jack_get_client_name"]
    pub fn jack_get_client_name(client: *mut jack_client_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the session ID for a client name."]
    #[doc = ""]
    #[doc = " The session manager needs this to reassociate a client name to the session_id."]
    #[doc = ""]
    #[doc = " The caller is responsible for calling jack_free(3) on any non-NULL"]
    #[doc = " returned value."]
    #[link_name = "\u{1}_jack_get_uuid_for_client_name"]
    pub fn jack_get_uuid_for_client_name(
        client: *mut jack_client_t,
        client_name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the client name for a session_id."]
    #[doc = ""]
    #[doc = " In order to snapshot the graph connections, the session manager needs to map"]
    #[doc = " session_ids to client names."]
    #[doc = ""]
    #[doc = " The caller is responsible for calling jack_free(3) on any non-NULL"]
    #[doc = " returned value."]
    #[link_name = "\u{1}_jack_get_client_name_by_uuid"]
    pub fn jack_get_client_name_by_uuid(
        client: *mut jack_client_t,
        client_uuid: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Load an internal client into the Jack server."]
    #[doc = ""]
    #[doc = " Internal clients run inside the JACK server process.  They can use"]
    #[doc = " most of the same functions as external clients.  Each internal"]
    #[doc = " client must declare jack_initialize() and jack_finish() entry"]
    #[doc = " points, called at load and unload times.  See inprocess.c for an"]
    #[doc = " example of how to write an internal client."]
    #[doc = ""]
    #[doc = " @deprecated Please use jack_internal_client_load()."]
    #[doc = ""]
    #[doc = " @param client_name of at most jack_client_name_size() characters."]
    #[doc = ""]
    #[doc = " @param load_name of a shared object file containing the code for"]
    #[doc = " the new client."]
    #[doc = ""]
    #[doc = " @param load_init an arbitary string passed to the jack_initialize()"]
    #[doc = " routine of the new client (may be NULL)."]
    #[doc = ""]
    #[doc = " @return 0 if successful."]
    #[link_name = "\u{1}_jack_internal_client_new"]
    pub fn jack_internal_client_new(
        client_name: *const ::std::os::raw::c_char,
        load_name: *const ::std::os::raw::c_char,
        load_init: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove an internal client from a JACK server."]
    #[doc = ""]
    #[doc = " @deprecated Please use jack_internal_client_unload()."]
    #[link_name = "\u{1}_jack_internal_client_close"]
    pub fn jack_internal_client_close(client_name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Tell the Jack server that the program is ready to start processing"]
    #[doc = " audio."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_activate"]
    pub fn jack_activate(client: *mut jack_client_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the Jack server to remove this @a client from the process"]
    #[doc = " graph.  Also, disconnect all ports belonging to it, since inactive"]
    #[doc = " clients have no port connections."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_deactivate"]
    pub fn jack_deactivate(client: *mut jack_client_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return pid of client. If not available, 0 will be returned."]
    #[link_name = "\u{1}_jack_get_client_pid"]
    pub fn jack_get_client_pid(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the pthread ID of the thread running the JACK client side"]
    #[doc = " real-time code."]
    #[link_name = "\u{1}_jack_client_thread_id"]
    pub fn jack_client_thread_id(client: *mut jack_client_t) -> jack_native_thread_t;
}
extern "C" {
    #[doc = " @param client pointer to JACK client structure."]
    #[doc = ""]
    #[doc = " Check if the JACK subsystem is running with -R (--realtime)."]
    #[doc = ""]
    #[doc = " @return 1 if JACK is running realtime, 0 otherwise"]
    #[link_name = "\u{1}_jack_is_realtime"]
    pub fn jack_is_realtime(client: *mut jack_client_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\bold THIS FUNCTION IS DEPRECATED AND SHOULD NOT BE USED IN"]
    #[doc = "  NEW JACK CLIENTS."]
    #[doc = ""]
    #[doc = " @deprecated Please use jack_cycle_wait() and jack_cycle_signal() functions."]
    #[link_name = "\u{1}_jack_thread_wait"]
    pub fn jack_thread_wait(
        client: *mut jack_client_t,
        status: ::std::os::raw::c_int,
    ) -> jack_nframes_t;
}
extern "C" {
    #[doc = " Wait until this JACK client should process data."]
    #[doc = ""]
    #[doc = " @param client - pointer to a JACK client structure"]
    #[doc = ""]
    #[doc = " @return the number of frames of data to process"]
    #[link_name = "\u{1}_jack_cycle_wait"]
    pub fn jack_cycle_wait(client: *mut jack_client_t) -> jack_nframes_t;
}
extern "C" {
    #[doc = " Signal next clients in the graph."]
    #[doc = ""]
    #[doc = " @param client - pointer to a JACK client structure"]
    #[doc = " @param status - if non-zero, calling thread should exit"]
    #[link_name = "\u{1}_jack_cycle_signal"]
    pub fn jack_cycle_signal(client: *mut jack_client_t, status: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Tell the Jack server to call @a thread_callback in the RT thread."]
    #[doc = " Typical use are in conjunction with @a jack_cycle_wait and @a jack_cycle_signal functions."]
    #[doc = " The code in the supplied function must be suitable for real-time"]
    #[doc = " execution.  That means that it cannot call functions that might"]
    #[doc = " block for a long time. This includes malloc, free, printf,"]
    #[doc = " pthread_mutex_lock, sleep, wait, poll, select, pthread_join,"]
    #[doc = " pthread_cond_wait, etc, etc. See"]
    #[doc = " http://jackit.sourceforge.net/docs/design/design.html#SECTION00411000000000000000"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[link_name = "\u{1}_jack_set_process_thread"]
    pub fn jack_set_process_thread(
        client: *mut jack_client_t,
        thread_callback: JackThreadCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell JACK to call @a thread_init_callback once just after"]
    #[doc = " the creation of the thread in which all other callbacks"]
    #[doc = " will be handled."]
    #[doc = ""]
    #[doc = " The code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code, causing JACK"]
    #[doc = " to remove that client from the process() graph."]
    #[link_name = "\u{1}_jack_set_thread_init_callback"]
    pub fn jack_set_thread_init_callback(
        client: *mut jack_client_t,
        thread_init_callback: JackThreadInitCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param client pointer to JACK client structure."]
    #[doc = " @param function The jack_shutdown function pointer."]
    #[doc = " @param arg The arguments for the jack_shutdown function."]
    #[doc = ""]
    #[doc = " Register a function (and argument) to be called if and when the"]
    #[doc = " JACK server shuts down the client thread.  The function must"]
    #[doc = " be written as if it were an asynchonrous POSIX signal"]
    #[doc = " handler --- use only async-safe functions, and remember that it"]
    #[doc = " is executed from another thread.  A typical function might"]
    #[doc = " set a flag or write to a pipe so that the rest of the"]
    #[doc = " application knows that the JACK client thread has shut"]
    #[doc = " down."]
    #[doc = ""]
    #[doc = " NOTE: clients do not need to call this.  It exists only"]
    #[doc = " to help more complex clients understand what is going"]
    #[doc = " on.  It should be called before jack_client_activate()."]
    #[doc = ""]
    #[doc = " NOTE: if a client calls this AND jack_on_info_shutdown(), then"]
    #[doc = " in case of a client thread shutdown, the callback"]
    #[doc = " passed to this function will not be called, and the one passed to"]
    #[doc = " jack_on_info_shutdown() will."]
    #[doc = ""]
    #[doc = " NOTE: application should typically signal another thread to correctly"]
    #[doc = " finish cleanup, that is by calling \"jack_client_close\""]
    #[doc = " (since \"jack_client_close\" cannot be called directly in the context"]
    #[doc = " of the thread that calls the shutdown callback)."]
    #[link_name = "\u{1}_jack_on_shutdown"]
    pub fn jack_on_shutdown(
        client: *mut jack_client_t,
        shutdown_callback: JackShutdownCallback,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @param client pointer to JACK client structure."]
    #[doc = " @param function The jack_info_shutdown function pointer."]
    #[doc = " @param arg The arguments for the jack_info_shutdown function."]
    #[doc = ""]
    #[doc = " Register a function (and argument) to be called if and when the"]
    #[doc = " JACK server shuts down the client thread.  The function must"]
    #[doc = " be written as if it were an asynchonrous POSIX signal"]
    #[doc = " handler --- use only async-safe functions, and remember that it"]
    #[doc = " is executed from another thread.  A typical function might"]
    #[doc = " set a flag or write to a pipe so that the rest of the"]
    #[doc = " application knows that the JACK client thread has shut"]
    #[doc = " down."]
    #[doc = ""]
    #[doc = " NOTE: clients do not need to call this.  It exists only"]
    #[doc = " to help more complex clients understand what is going"]
    #[doc = " on.  It should be called before jack_client_activate()."]
    #[doc = ""]
    #[doc = " NOTE: if a client calls this AND jack_on_shutdown(), then"]
    #[doc = " in case of a client thread shutdown, the callback passed to"]
    #[doc = " jack_on_info_shutdown() will be called."]
    #[doc = ""]
    #[doc = " NOTE: application should typically signal another thread to correctly"]
    #[doc = " finish cleanup, that is by calling \"jack_client_close\""]
    #[doc = " (since \"jack_client_close\" cannot be called directly in the context"]
    #[doc = " of the thread that calls the shutdown callback)."]
    #[link_name = "\u{1}_jack_on_info_shutdown"]
    pub fn jack_on_info_shutdown(
        client: *mut jack_client_t,
        shutdown_callback: JackInfoShutdownCallback,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Tell the Jack server to call @a process_callback whenever there is"]
    #[doc = " work be done, passing @a arg as the second argument."]
    #[doc = ""]
    #[doc = " The code in the supplied function must be suitable for real-time"]
    #[doc = " execution.  That means that it cannot call functions that might"]
    #[doc = " block for a long time. This includes malloc, free, printf,"]
    #[doc = " pthread_mutex_lock, sleep, wait, poll, select, pthread_join,"]
    #[doc = " pthread_cond_wait, etc, etc. See"]
    #[doc = " http://jackit.sourceforge.net/docs/design/design.html#SECTION00411000000000000000"]
    #[doc = " for more information."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[link_name = "\u{1}_jack_set_process_callback"]
    pub fn jack_set_process_callback(
        client: *mut jack_client_t,
        process_callback: JackProcessCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the Jack server to call @a freewheel_callback"]
    #[doc = " whenever we enter or leave \"freewheel\" mode, passing @a"]
    #[doc = " arg as the second argument. The first argument to the"]
    #[doc = " callback will be non-zero if JACK is entering freewheel"]
    #[doc = " mode, and zero otherwise."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[link_name = "\u{1}_jack_set_freewheel_callback"]
    pub fn jack_set_freewheel_callback(
        client: *mut jack_client_t,
        freewheel_callback: JackFreewheelCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell JACK to call @a bufsize_callback whenever the size of the the"]
    #[doc = " buffer that will be passed to the @a process_callback is about to"]
    #[doc = " change.  Clients that depend on knowing the buffer size must supply"]
    #[doc = " a @a bufsize_callback before activating themselves."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @param client pointer to JACK client structure."]
    #[doc = " @param bufsize_callback function to call when the buffer size changes."]
    #[doc = " @param arg argument for @a bufsize_callback."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_buffer_size_callback"]
    pub fn jack_set_buffer_size_callback(
        client: *mut jack_client_t,
        bufsize_callback: JackBufferSizeCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the Jack server to call @a srate_callback whenever the system"]
    #[doc = " sample rate changes."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_sample_rate_callback"]
    pub fn jack_set_sample_rate_callback(
        client: *mut jack_client_t,
        srate_callback: JackSampleRateCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the JACK server to call @a client_registration_callback whenever a"]
    #[doc = " client is registered or unregistered, passing @a arg as a parameter."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_client_registration_callback"]
    pub fn jack_set_client_registration_callback(
        client: *mut jack_client_t,
        registration_callback: JackClientRegistrationCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the JACK server to call @a registration_callback whenever a"]
    #[doc = " port is registered or unregistered, passing @a arg as a parameter."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_port_registration_callback"]
    pub fn jack_set_port_registration_callback(
        client: *mut jack_client_t,
        registration_callback: JackPortRegistrationCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the JACK server to call @a connect_callback whenever a"]
    #[doc = " port is connected or disconnected, passing @a arg as a parameter."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_port_connect_callback"]
    pub fn jack_set_port_connect_callback(
        client: *mut jack_client_t,
        connect_callback: JackPortConnectCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the JACK server to call @a rename_callback whenever a"]
    #[doc = " port is renamed, passing @a arg as a parameter."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_port_rename_callback"]
    pub fn jack_set_port_rename_callback(
        client: *mut jack_client_t,
        rename_callback: JackPortRenameCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the JACK server to call @a graph_callback whenever the"]
    #[doc = " processing graph is reordered, passing @a arg as a parameter."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_graph_order_callback"]
    pub fn jack_set_graph_order_callback(
        client: *mut jack_client_t,
        graph_callback: JackGraphOrderCallback,
        arg1: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the JACK server to call @a xrun_callback whenever there is a"]
    #[doc = " xrun, passing @a arg as a parameter."]
    #[doc = ""]
    #[doc = " All \"notification events\" are received in a seperated non RT thread,"]
    #[doc = " the code in the supplied function does not need to be"]
    #[doc = " suitable for real-time execution."]
    #[doc = ""]
    #[doc = " NOTE: this function cannot be called while the client is activated"]
    #[doc = " (after jack_activate has been called.)"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_xrun_callback"]
    pub fn jack_set_xrun_callback(
        client: *mut jack_client_t,
        xrun_callback: JackXRunCallback,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the Jack server to call @a latency_callback whenever it"]
    #[doc = " is necessary to recompute the latencies for some or all"]
    #[doc = " Jack ports."]
    #[doc = ""]
    #[doc = " @a latency_callback will be called twice each time it is"]
    #[doc = " needed, once being passed JackCaptureLatency and once"]
    #[doc = " JackPlaybackLatency. See @ref LatencyFunctions for"]
    #[doc = " the definition of each type of latency and related functions."]
    #[doc = ""]
    #[doc = " <b>IMPORTANT: Most JACK clients do NOT need to register a latency"]
    #[doc = " callback.</b>"]
    #[doc = ""]
    #[doc = " Clients that meet any of the following conditions do NOT"]
    #[doc = " need to register a latency callback:"]
    #[doc = ""]
    #[doc = "    - have only input ports"]
    #[doc = "    - have only output ports"]
    #[doc = "    - their output is totally unrelated to their input"]
    #[doc = "    - their output is not delayed relative to their input"]
    #[doc = "        (i.e. data that arrives in a given process()"]
    #[doc = "         callback is processed and output again in the"]
    #[doc = "         same callback)"]
    #[doc = ""]
    #[doc = " Clients NOT registering a latency callback MUST also"]
    #[doc = " satisfy this condition:"]
    #[doc = ""]
    #[doc = "    - have no multiple distinct internal signal pathways"]
    #[doc = ""]
    #[doc = " This means that if your client has more than 1 input and"]
    #[doc = " output port, and considers them always \"correlated\""]
    #[doc = " (e.g. as a stereo pair), then there is only 1 (e.g. stereo)"]
    #[doc = " signal pathway through the client. This would be true,"]
    #[doc = " for example, of a stereo FX rack client that has a"]
    #[doc = " left/right input pair and a left/right output pair."]
    #[doc = ""]
    #[doc = " However, this is somewhat a matter of perspective. The"]
    #[doc = " same FX rack client could be connected so that its"]
    #[doc = " two input ports were connected to entirely separate"]
    #[doc = " sources. Under these conditions, the fact that the client"]
    #[doc = " does not register a latency callback MAY result"]
    #[doc = " in port latency values being incorrect."]
    #[doc = ""]
    #[doc = " Clients that do not meet any of those conditions SHOULD"]
    #[doc = " register a latency callback."]
    #[doc = ""]
    #[doc = " See the documentation for  @ref jack_port_set_latency_range()"]
    #[doc = " on how the callback should operate. Remember that the @a mode"]
    #[doc = " argument given to the latency callback will need to be"]
    #[doc = " passed into @ref jack_port_set_latency_range()"]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_latency_callback"]
    pub fn jack_set_latency_callback(
        client: *mut jack_client_t,
        latency_callback: JackLatencyCallback,
        arg1: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start/Stop JACK\'s \"freewheel\" mode."]
    #[doc = ""]
    #[doc = " When in \"freewheel\" mode, JACK no longer waits for"]
    #[doc = " any external event to begin the start of the next process"]
    #[doc = " cycle."]
    #[doc = ""]
    #[doc = " As a result, freewheel mode causes \"faster than realtime\""]
    #[doc = " execution of a JACK graph. If possessed, real-time"]
    #[doc = " scheduling is dropped when entering freewheel mode, and"]
    #[doc = " if appropriate it is reacquired when stopping."]
    #[doc = ""]
    #[doc = " IMPORTANT: on systems using capabilities to provide real-time"]
    #[doc = " scheduling (i.e. Linux kernel 2.4), if onoff is zero, this function"]
    #[doc = " must be called from the thread that originally called jack_activate()."]
    #[doc = " This restriction does not apply to other systems (e.g. Linux kernel 2.6"]
    #[doc = " or OS X)."]
    #[doc = ""]
    #[doc = " @param client pointer to JACK client structure"]
    #[doc = " @param onoff  if non-zero, freewheel mode starts. Otherwise"]
    #[doc = "                  freewheel mode ends."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[link_name = "\u{1}_jack_set_freewheel"]
    pub fn jack_set_freewheel(
        client: *mut jack_client_t,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the buffer size passed to the @a process_callback."]
    #[doc = ""]
    #[doc = " This operation stops the JACK engine process cycle, then calls all"]
    #[doc = " registered @a bufsize_callback functions before restarting the"]
    #[doc = " process cycle.  This will cause a gap in the audio flow, so it"]
    #[doc = " should only be done at appropriate stopping points."]
    #[doc = ""]
    #[doc = " @see jack_set_buffer_size_callback()"]
    #[doc = ""]
    #[doc = " @param client pointer to JACK client structure."]
    #[doc = " @param nframes new buffer size.  Must be a power of two."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_set_buffer_size"]
    pub fn jack_set_buffer_size(
        client: *mut jack_client_t,
        nframes: jack_nframes_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the sample rate of the jack system, as set by the user when"]
    #[doc = " jackd was started."]
    #[link_name = "\u{1}_jack_get_sample_rate"]
    pub fn jack_get_sample_rate(arg1: *mut jack_client_t) -> jack_nframes_t;
}
extern "C" {
    #[doc = " @return the current maximum size that will ever be passed to the @a"]
    #[doc = " process_callback.  It should only be used *before* the client has"]
    #[doc = " been activated.  This size may change, clients that depend on it"]
    #[doc = " must register a @a bufsize_callback so they will be notified if it"]
    #[doc = " does."]
    #[doc = ""]
    #[doc = " @see jack_set_buffer_size_callback()"]
    #[link_name = "\u{1}_jack_get_buffer_size"]
    pub fn jack_get_buffer_size(arg1: *mut jack_client_t) -> jack_nframes_t;
}
extern "C" {
    #[doc = " Old-style interface to become the timebase for the entire JACK"]
    #[doc = " subsystem."]
    #[doc = ""]
    #[doc = " @deprecated This function still exists for compatibility with the"]
    #[doc = " earlier transport interface, but it does nothing.  Instead, see"]
    #[doc = " transport.h and use jack_set_timebase_callback()."]
    #[doc = ""]
    #[doc = " @return ENOSYS, function not implemented."]
    #[link_name = "\u{1}_jack_engine_takeover_timebase"]
    pub fn jack_engine_takeover_timebase(arg1: *mut jack_client_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the current CPU load estimated by JACK.  This is a running"]
    #[doc = " average of the time it takes to execute a full process cycle for"]
    #[doc = " all clients as a percentage of the real time available per cycle"]
    #[doc = " determined by the buffer size and sample rate."]
    #[link_name = "\u{1}_jack_cpu_load"]
    pub fn jack_cpu_load(client: *mut jack_client_t) -> f32;
}
extern "C" {
    #[doc = " Create a new port for the client. This is an object used for moving"]
    #[doc = " data of any type in or out of the client.  Ports may be connected"]
    #[doc = " in various ways."]
    #[doc = ""]
    #[doc = " Each port has a short name.  The port\'s full name contains the name"]
    #[doc = " of the client concatenated with a colon (:) followed by its short"]
    #[doc = " name.  The jack_port_name_size() is the maximum length of this full"]
    #[doc = " name.  Exceeding that will cause the port registration to fail and"]
    #[doc = " return NULL."]
    #[doc = ""]
    #[doc = " The @a port_name must be unique among all ports owned by this client."]
    #[doc = " If the name is not unique, the registration will fail."]
    #[doc = ""]
    #[doc = " All ports have a type, which may be any non-NULL and non-zero"]
    #[doc = " length string, passed as an argument.  Some port types are built"]
    #[doc = " into the JACK API, currently only JACK_DEFAULT_AUDIO_TYPE."]
    #[doc = ""]
    #[doc = " @param client pointer to JACK client structure."]
    #[doc = " @param port_name non-empty short name for the new port (not"]
    #[doc = " including the leading @a \"client_name:\"). Must be unique."]
    #[doc = " @param port_type port type name.  If longer than"]
    #[doc = " jack_port_type_size(), only that many characters are significant."]
    #[doc = " @param flags @ref JackPortFlags bit mask."]
    #[doc = " @param buffer_size must be non-zero if this is not a built-in @a"]
    #[doc = " port_type.  Otherwise, it is ignored."]
    #[doc = ""]
    #[doc = " @return jack_port_t pointer on success, otherwise NULL."]
    #[link_name = "\u{1}_jack_port_register"]
    pub fn jack_port_register(
        client: *mut jack_client_t,
        port_name: *const ::std::os::raw::c_char,
        port_type: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
        buffer_size: ::std::os::raw::c_ulong,
    ) -> *mut jack_port_t;
}
extern "C" {
    #[doc = " Remove the port from the client, disconnecting any existing"]
    #[doc = " connections."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_port_unregister"]
    pub fn jack_port_unregister(
        client: *mut jack_client_t,
        port: *mut jack_port_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This returns a pointer to the memory area associated with the"]
    #[doc = " specified port. For an output port, it will be a memory area"]
    #[doc = " that can be written to; for an input port, it will be an area"]
    #[doc = " containing the data from the port\'s connection(s), or"]
    #[doc = " zero-filled. if there are multiple inbound connections, the data"]
    #[doc = " will be mixed appropriately."]
    #[doc = ""]
    #[doc = " FOR OUTPUT PORTS ONLY : DEPRECATED in Jack 2.0 !!"]
    #[doc = " ---------------------------------------------------"]
    #[doc = " You may cache the value returned, but only between calls to"]
    #[doc = " your \"blocksize\" callback. For this reason alone, you should"]
    #[doc = " either never cache the return value or ensure you have"]
    #[doc = " a \"blocksize\" callback and be sure to invalidate the cached"]
    #[doc = " address from there."]
    #[doc = ""]
    #[doc = " Caching output ports is DEPRECATED in Jack 2.0, due to some new optimization (like \"pipelining\")."]
    #[doc = " Port buffers have to be retrieved in each callback for proper functionning."]
    #[link_name = "\u{1}_jack_port_get_buffer"]
    pub fn jack_port_get_buffer(
        port: *mut jack_port_t,
        arg1: jack_nframes_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @return the UUID of the jack_port_t"]
    #[doc = ""]
    #[doc = " @see jack_uuid_to_string() to convert into a string representation"]
    #[link_name = "\u{1}_jack_port_uuid"]
    pub fn jack_port_uuid(port: *const jack_port_t) -> jack_uuid_t;
}
extern "C" {
    #[doc = " @return the full name of the jack_port_t (including the @a"]
    #[doc = " \"client_name:\" prefix)."]
    #[doc = ""]
    #[doc = " @see jack_port_name_size()."]
    #[link_name = "\u{1}_jack_port_name"]
    pub fn jack_port_name(port: *const jack_port_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the short name of the jack_port_t (not including the @a"]
    #[doc = " \"client_name:\" prefix)."]
    #[doc = ""]
    #[doc = " @see jack_port_name_size()."]
    #[link_name = "\u{1}_jack_port_short_name"]
    pub fn jack_port_short_name(port: *const jack_port_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the @ref JackPortFlags of the jack_port_t."]
    #[link_name = "\u{1}_jack_port_flags"]
    pub fn jack_port_flags(port: *const jack_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the @a port type, at most jack_port_type_size() characters"]
    #[doc = " including a final NULL."]
    #[link_name = "\u{1}_jack_port_type"]
    pub fn jack_port_type(port: *const jack_port_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the @a port type id."]
    #[link_name = "\u{1}_jack_port_type_id"]
    pub fn jack_port_type_id(port: *const jack_port_t) -> jack_port_type_id_t;
}
extern "C" {
    #[doc = " @return TRUE if the jack_port_t belongs to the jack_client_t."]
    #[link_name = "\u{1}_jack_port_is_mine"]
    pub fn jack_port_is_mine(
        client: *const jack_client_t,
        port: *const jack_port_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return number of connections to or from @a port."]
    #[doc = ""]
    #[doc = " @pre The calling client must own @a port."]
    #[link_name = "\u{1}_jack_port_connected"]
    pub fn jack_port_connected(port: *const jack_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return TRUE if the locally-owned @a port is @b directly connected"]
    #[doc = " to the @a port_name."]
    #[doc = ""]
    #[doc = " @see jack_port_name_size()"]
    #[link_name = "\u{1}_jack_port_connected_to"]
    pub fn jack_port_connected_to(
        port: *const jack_port_t,
        port_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a null-terminated array of full port names to which the @a"]
    #[doc = " port is connected.  If none, returns NULL."]
    #[doc = ""]
    #[doc = " The caller is responsible for calling jack_free() on any non-NULL"]
    #[doc = " returned value."]
    #[doc = ""]
    #[doc = " @param port locally owned jack_port_t pointer."]
    #[doc = ""]
    #[doc = " @see jack_port_name_size(), jack_port_get_all_connections()"]
    #[link_name = "\u{1}_jack_port_get_connections"]
    pub fn jack_port_get_connections(
        port: *const jack_port_t,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return a null-terminated array of full port names to which the @a"]
    #[doc = " port is connected.  If none, returns NULL."]
    #[doc = ""]
    #[doc = " The caller is responsible for calling jack_free() on any non-NULL"]
    #[doc = " returned value."]
    #[doc = ""]
    #[doc = " This differs from jack_port_get_connections() in two important"]
    #[doc = " respects:"]
    #[doc = ""]
    #[doc = "     1) You may not call this function from code that is"]
    #[doc = "          executed in response to a JACK event. For example,"]
    #[doc = "          you cannot use it in a GraphReordered handler."]
    #[doc = ""]
    #[doc = "     2) You need not be the owner of the port to get information"]
    #[doc = "          about its connections."]
    #[doc = ""]
    #[doc = " @see jack_port_name_size()"]
    #[link_name = "\u{1}_jack_port_get_all_connections"]
    pub fn jack_port_get_all_connections(
        client: *const jack_client_t,
        port: *const jack_port_t,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @deprecated This function will be removed from a future version"]
    #[doc = " of JACK. Do not use it. There is no replacement. It has"]
    #[doc = " turned out to serve essentially no purpose in real-life"]
    #[doc = " JACK clients."]
    #[link_name = "\u{1}_jack_port_tie"]
    pub fn jack_port_tie(src: *mut jack_port_t, dst: *mut jack_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @deprecated This function will be removed from a future version"]
    #[doc = " of JACK. Do not use it. There is no replacement. It has"]
    #[doc = " turned out to serve essentially no purpose in real-life"]
    #[doc = " JACK clients."]
    #[link_name = "\u{1}_jack_port_untie"]
    pub fn jack_port_untie(port: *mut jack_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\bold THIS FUNCTION IS DEPRECATED AND SHOULD NOT BE USED IN"]
    #[doc = "  NEW JACK CLIENTS"]
    #[doc = ""]
    #[doc = " Modify a port\'s short name.  May be called at any time.  If the"]
    #[doc = " resulting full name (including the @a \"client_name:\" prefix) is"]
    #[doc = " longer than jack_port_name_size(), it will be truncated."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[link_name = "\u{1}_jack_port_set_name"]
    pub fn jack_port_set_name(
        port: *mut jack_port_t,
        port_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Modify a port\'s short name.  May NOT be called from a callback handling a server event."]
    #[doc = " If the resulting full name (including the @a \"client_name:\" prefix) is"]
    #[doc = " longer than jack_port_name_size(), it will be truncated."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[doc = ""]
    #[doc = " This differs from jack_port_set_name() by triggering PortRename notifications to"]
    #[doc = " clients that have registered a port rename handler."]
    #[link_name = "\u{1}_jack_port_rename"]
    pub fn jack_port_rename(
        client: *mut jack_client_t,
        port: *mut jack_port_t,
        port_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set @a alias as an alias for @a port.  May be called at any time."]
    #[doc = " If the alias is longer than jack_port_name_size(), it will be truncated."]
    #[doc = ""]
    #[doc = " After a successful call, and until JACK exits or"]
    #[doc = " @function jack_port_unset_alias() is called, @alias may be"]
    #[doc = " used as a alternate name for the port."]
    #[doc = ""]
    #[doc = " Ports can have up to two aliases - if both are already"]
    #[doc = " set, this function will return an error."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[link_name = "\u{1}_jack_port_set_alias"]
    pub fn jack_port_set_alias(
        port: *mut jack_port_t,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove @a alias as an alias for @a port.  May be called at any time."]
    #[doc = ""]
    #[doc = " After a successful call, @a alias can no longer be"]
    #[doc = " used as a alternate name for the port."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[link_name = "\u{1}_jack_port_unset_alias"]
    pub fn jack_port_unset_alias(
        port: *mut jack_port_t,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get any aliases known for @port."]
    #[doc = ""]
    #[doc = " @return the number of aliases discovered for the port"]
    #[link_name = "\u{1}_jack_port_get_aliases"]
    pub fn jack_port_get_aliases(
        port: *const jack_port_t,
        aliases: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If @ref JackPortCanMonitor is set for this @a port, turn input"]
    #[doc = " monitoring on or off.  Otherwise, do nothing."]
    #[link_name = "\u{1}_jack_port_request_monitor"]
    pub fn jack_port_request_monitor(
        port: *mut jack_port_t,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If @ref JackPortCanMonitor is set for this @a port_name, turn input"]
    #[doc = " monitoring on or off.  Otherwise, do nothing."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code."]
    #[doc = ""]
    #[doc = " @see jack_port_name_size()"]
    #[link_name = "\u{1}_jack_port_request_monitor_by_name"]
    pub fn jack_port_request_monitor_by_name(
        client: *mut jack_client_t,
        port_name: *const ::std::os::raw::c_char,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If @ref JackPortCanMonitor is set for a port, this function turns"]
    #[doc = " on input monitoring if it was off, and turns it off if only one"]
    #[doc = " request has been made to turn it on.  Otherwise it does nothing."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_port_ensure_monitor"]
    pub fn jack_port_ensure_monitor(
        port: *mut jack_port_t,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return TRUE if input monitoring has been requested for @a port."]
    #[link_name = "\u{1}_jack_port_monitoring_input"]
    pub fn jack_port_monitoring_input(port: *mut jack_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Establish a connection between two ports."]
    #[doc = ""]
    #[doc = " When a connection exists, data written to the source port will"]
    #[doc = " be available to be read at the destination port."]
    #[doc = ""]
    #[doc = " @pre The port types must be identical."]
    #[doc = ""]
    #[doc = " @pre The @ref JackPortFlags of the @a source_port must include @ref"]
    #[doc = " JackPortIsOutput."]
    #[doc = ""]
    #[doc = " @pre The @ref JackPortFlags of the @a destination_port must include"]
    #[doc = " @ref JackPortIsInput."]
    #[doc = ""]
    #[doc = " @return 0 on success, EEXIST if the connection is already made,"]
    #[doc = " otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_connect"]
    pub fn jack_connect(
        client: *mut jack_client_t,
        source_port: *const ::std::os::raw::c_char,
        destination_port: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a connection between two ports."]
    #[doc = ""]
    #[doc = " @pre The port types must be identical."]
    #[doc = ""]
    #[doc = " @pre The @ref JackPortFlags of the @a source_port must include @ref"]
    #[doc = " JackPortIsOutput."]
    #[doc = ""]
    #[doc = " @pre The @ref JackPortFlags of the @a destination_port must include"]
    #[doc = " @ref JackPortIsInput."]
    #[doc = ""]
    #[doc = " @return 0 on success, otherwise a non-zero error code"]
    #[link_name = "\u{1}_jack_disconnect"]
    pub fn jack_disconnect(
        client: *mut jack_client_t,
        source_port: *const ::std::os::raw::c_char,
        destination_port: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform the same function as jack_disconnect() using port handles"]
    #[doc = " rather than names.  This avoids the name lookup inherent in the"]
    #[doc = " name-based version."]
    #[doc = ""]
    #[doc = " Clients connecting their own ports are likely to use this function,"]
    #[doc = " while generic connection clients (e.g. patchbays) would use"]
    #[doc = " jack_disconnect()."]
    #[link_name = "\u{1}_jack_port_disconnect"]
    pub fn jack_port_disconnect(
        client: *mut jack_client_t,
        port: *mut jack_port_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the maximum number of characters in a full JACK port name"]
    #[doc = " including the final NULL character.  This value is a constant."]
    #[doc = ""]
    #[doc = " A port\'s full name contains the owning client name concatenated"]
    #[doc = " with a colon (:) followed by its short name and a NULL"]
    #[doc = " character."]
    #[link_name = "\u{1}_jack_port_name_size"]
    pub fn jack_port_name_size() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the maximum number of characters in a JACK port type name"]
    #[doc = " including the final NULL character.  This value is a constant."]
    #[link_name = "\u{1}_jack_port_type_size"]
    pub fn jack_port_type_size() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the buffersize of a port of type @arg port_type."]
    #[doc = ""]
    #[doc = " this function may only be called in a buffer_size callback."]
    #[link_name = "\u{1}_jack_port_type_get_buffer_size"]
    pub fn jack_port_type_get_buffer_size(
        client: *mut jack_client_t,
        port_type: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " The port latency is zero by default. Clients that control"]
    #[doc = " physical hardware with non-zero latency should call this"]
    #[doc = " to set the latency to its correct value. Note that the value"]
    #[doc = " should include any systemic latency present \"outside\" the"]
    #[doc = " physical hardware controlled by the client. For example,"]
    #[doc = " for a client controlling a digital audio interface connected"]
    #[doc = " to an external digital converter, the latency setting should"]
    #[doc = " include both buffering by the audio interface *and* the converter."]
    #[doc = ""]
    #[doc = " @deprecated This method will be removed in the next major"]
    #[doc = " release of JACK. It should not be used in new code, and should"]
    #[doc = " be replaced by a latency callback that calls @ref"]
    #[doc = " jack_port_set_latency_range()."]
    #[link_name = "\u{1}_jack_port_set_latency"]
    pub fn jack_port_set_latency(port: *mut jack_port_t, arg1: jack_nframes_t);
}
extern "C" {
    #[doc = " return the latency range defined by @a mode for"]
    #[doc = " @a port, in frames."]
    #[doc = ""]
    #[doc = " See @ref LatencyFunctions for the definition of each latency value."]
    #[doc = ""]
    #[doc = " This is normally used in the LatencyCallback."]
    #[doc = " and therefor safe to execute from callbacks."]
    #[link_name = "\u{1}_jack_port_get_latency_range"]
    pub fn jack_port_get_latency_range(
        port: *mut jack_port_t,
        mode: jack_latency_callback_mode_t,
        range: *mut jack_latency_range_t,
    );
}
extern "C" {
    #[doc = " set the minimum and maximum latencies defined by"]
    #[doc = " @a mode for @a port, in frames."]
    #[doc = ""]
    #[doc = " See @ref LatencyFunctions for the definition of each latency value."]
    #[doc = ""]
    #[doc = " This function should ONLY be used inside a latency"]
    #[doc = " callback. The client should determine the current"]
    #[doc = " value of the latency using @ref jack_port_get_latency_range()"]
    #[doc = " (called using the same mode as @a mode)"]
    #[doc = " and then add some number of frames to that reflects"]
    #[doc = " latency added by the client."]
    #[doc = ""]
    #[doc = " How much latency a client adds will vary"]
    #[doc = " dramatically. For most clients, the answer is zero"]
    #[doc = " and there is no reason for them to register a latency"]
    #[doc = " callback and thus they should never call this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " More complex clients that take an input signal,"]
    #[doc = " transform it in some way and output the result but"]
    #[doc = " not during the same process() callback will"]
    #[doc = " generally know a single constant value to add"]
    #[doc = " to the value returned by @ref jack_port_get_latency_range()."]
    #[doc = ""]
    #[doc = " Such clients would register a latency callback (see"]
    #[doc = " @ref jack_set_latency_callback) and must know what input"]
    #[doc = " ports feed which output ports as part of their"]
    #[doc = " internal state. Their latency callback will update"]
    #[doc = " the ports\' latency values appropriately."]
    #[doc = ""]
    #[doc = " A pseudo-code example will help. The @a mode argument to the latency"]
    #[doc = " callback will determine whether playback or capture"]
    #[doc = " latency is being set. The callback will use"]
    #[doc = " @ref jack_port_set_latency_range() as follows:"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " jack_latency_range_t range;"]
    #[doc = " if (mode == JackPlaybackLatency) {"]
    #[doc = "  foreach input_port in (all self-registered port) {"]
    #[doc = "   jack_port_get_latency_range (port_feeding_input_port, JackPlaybackLatency, &range);"]
    #[doc = "   range.min += min_delay_added_as_signal_flows_from port_feeding to input_port;"]
    #[doc = "   range.max += max_delay_added_as_signal_flows_from port_feeding to input_port;"]
    #[doc = "   jack_port_set_latency_range (input_port, JackPlaybackLatency, &range);"]
    #[doc = "  }"]
    #[doc = " } else if (mode == JackCaptureLatency) {"]
    #[doc = "  foreach output_port in (all self-registered port) {"]
    #[doc = "   jack_port_get_latency_range (port_fed_by_output_port, JackCaptureLatency, &range);"]
    #[doc = "   range.min += min_delay_added_as_signal_flows_from_output_port_to_fed_by_port;"]
    #[doc = "   range.max += max_delay_added_as_signal_flows_from_output_port_to_fed_by_port;"]
    #[doc = "   jack_port_set_latency_range (output_port, JackCaptureLatency, &range);"]
    #[doc = "  }"]
    #[doc = " }"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " In this relatively simple pseudo-code example, it is assumed that"]
    #[doc = " each input port or output is connected to only 1 output or input"]
    #[doc = " port respectively."]
    #[doc = ""]
    #[doc = " If a port is connected to more than 1 other port, then the"]
    #[doc = " range.min and range.max values passed to @ref"]
    #[doc = " jack_port_set_latency_range() should reflect the minimum and"]
    #[doc = " maximum values across all connected ports."]
    #[doc = ""]
    #[doc = " See the description of @ref jack_set_latency_callback for more"]
    #[doc = " information."]
    #[link_name = "\u{1}_jack_port_set_latency_range"]
    pub fn jack_port_set_latency_range(
        port: *mut jack_port_t,
        mode: jack_latency_callback_mode_t,
        range: *mut jack_latency_range_t,
    );
}
extern "C" {
    #[doc = " Request a complete recomputation of all port latencies. This"]
    #[doc = " can be called by a client that has just changed the internal"]
    #[doc = " latency of its port using  jack_port_set_latency"]
    #[doc = " and wants to ensure that all signal pathways in the graph"]
    #[doc = " are updated with respect to the values that will be returned"]
    #[doc = " by  jack_port_get_total_latency. It allows a client"]
    #[doc = " to change multiple port latencies without triggering a"]
    #[doc = " recompute for each change."]
    #[doc = ""]
    #[doc = " @return zero for successful execution of the request. non-zero"]
    #[doc = "         otherwise."]
    #[link_name = "\u{1}_jack_recompute_total_latencies"]
    pub fn jack_recompute_total_latencies(client: *mut jack_client_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the time (in frames) between data being available or"]
    #[doc = " delivered at/to a port, and the time at which it arrived at or is"]
    #[doc = " delivered to the \"other side\" of the port.  E.g. for a physical"]
    #[doc = " audio output port, this is the time between writing to the port and"]
    #[doc = " when the signal will leave the connector.  For a physical audio"]
    #[doc = " input port, this is the time between the sound arriving at the"]
    #[doc = " connector and the corresponding frames being readable from the"]
    #[doc = " port."]
    #[doc = ""]
    #[doc = " @deprecated This method will be removed in the next major"]
    #[doc = " release of JACK. It should not be used in new code, and should"]
    #[doc = " be replaced by jack_port_get_latency_range() in any existing"]
    #[doc = " use cases."]
    #[link_name = "\u{1}_jack_port_get_latency"]
    pub fn jack_port_get_latency(port: *mut jack_port_t) -> jack_nframes_t;
}
extern "C" {
    #[doc = " The maximum of the sum of the latencies in every"]
    #[doc = " connection path that can be drawn between the port and other"]
    #[doc = " ports with the @ref JackPortIsTerminal flag set."]
    #[doc = ""]
    #[doc = " @deprecated This method will be removed in the next major"]
    #[doc = " release of JACK. It should not be used in new code, and should"]
    #[doc = " be replaced by jack_port_get_latency_range() in any existing"]
    #[doc = " use cases."]
    #[link_name = "\u{1}_jack_port_get_total_latency"]
    pub fn jack_port_get_total_latency(
        client: *mut jack_client_t,
        port: *mut jack_port_t,
    ) -> jack_nframes_t;
}
extern "C" {
    #[doc = " Request a complete recomputation of a port\'s total latency. This"]
    #[doc = " can be called by a client that has just changed the internal"]
    #[doc = " latency of its port using  jack_port_set_latency"]
    #[doc = " and wants to ensure that all signal pathways in the graph"]
    #[doc = " are updated with respect to the values that will be returned"]
    #[doc = " by  jack_port_get_total_latency."]
    #[doc = ""]
    #[doc = " @return zero for successful execution of the request. non-zero"]
    #[doc = "         otherwise."]
    #[doc = ""]
    #[doc = " @deprecated This method will be removed in the next major"]
    #[doc = " release of JACK. It should not be used in new code, and should"]
    #[doc = " be replaced by jack_recompute_total_latencies() in any existing"]
    #[doc = " use cases."]
    #[link_name = "\u{1}_jack_recompute_total_latency"]
    pub fn jack_recompute_total_latency(
        arg1: *mut jack_client_t,
        port: *mut jack_port_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param port_name_pattern A regular expression used to select"]
    #[doc = " ports by name.  If NULL or of zero length, no selection based"]
    #[doc = " on name will be carried out."]
    #[doc = " @param type_name_pattern A regular expression used to select"]
    #[doc = " ports by type.  If NULL or of zero length, no selection based"]
    #[doc = " on type will be carried out."]
    #[doc = " @param flags A value used to select ports by their flags."]
    #[doc = " If zero, no selection based on flags will be carried out."]
    #[doc = ""]
    #[doc = " @return a NULL-terminated array of ports that match the specified"]
    #[doc = " arguments.  The caller is responsible for calling jack_free() any"]
    #[doc = " non-NULL returned value."]
    #[doc = ""]
    #[doc = " @see jack_port_name_size(), jack_port_type_size()"]
    #[link_name = "\u{1}_jack_get_ports"]
    pub fn jack_get_ports(
        client: *mut jack_client_t,
        port_name_pattern: *const ::std::os::raw::c_char,
        type_name_pattern: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return address of the jack_port_t named @a port_name."]
    #[doc = ""]
    #[doc = " @see jack_port_name_size()"]
    #[link_name = "\u{1}_jack_port_by_name"]
    pub fn jack_port_by_name(
        client: *mut jack_client_t,
        port_name: *const ::std::os::raw::c_char,
    ) -> *mut jack_port_t;
}
extern "C" {
    #[doc = " @return address of the jack_port_t of a @a port_id."]
    #[link_name = "\u{1}_jack_port_by_id"]
    pub fn jack_port_by_id(client: *mut jack_client_t, port_id: jack_port_id_t)
        -> *mut jack_port_t;
}
extern "C" {
    #[doc = " @return the estimated time in frames that has passed since the JACK"]
    #[doc = " server began the current process cycle."]
    #[link_name = "\u{1}_jack_frames_since_cycle_start"]
    pub fn jack_frames_since_cycle_start(arg1: *const jack_client_t) -> jack_nframes_t;
}
extern "C" {
    #[doc = " @return the estimated current time in frames."]
    #[doc = " This function is intended for use in other threads (not the process"]
    #[doc = " callback).  The return value can be compared with the value of"]
    #[doc = " jack_last_frame_time to relate time in other threads to JACK time."]
    #[link_name = "\u{1}_jack_frame_time"]
    pub fn jack_frame_time(arg1: *const jack_client_t) -> jack_nframes_t;
}
extern "C" {
    #[doc = " @return the precise time at the start of the current process cycle."]
    #[doc = " This function may only be used from the process callback, and can"]
    #[doc = " be used to interpret timestamps generated by jack_frame_time() in"]
    #[doc = " other threads with respect to the current process cycle."]
    #[doc = ""]
    #[doc = " This is the only jack time function that returns exact time:"]
    #[doc = " when used during the process callback it always returns the same"]
    #[doc = " value (until the next process callback, where it will return"]
    #[doc = " that value + nframes, etc).  The return value is guaranteed to be"]
    #[doc = " monotonic and linear in this fashion unless an xrun occurs."]
    #[doc = " If an xrun occurs, clients must check this value again, as time"]
    #[doc = " may have advanced in a non-linear way (e.g. cycles may have been skipped)."]
    #[link_name = "\u{1}_jack_last_frame_time"]
    pub fn jack_last_frame_time(client: *const jack_client_t) -> jack_nframes_t;
}
extern "C" {
    #[doc = " This function may only be used from the process callback."]
    #[doc = " It provides the internal cycle timing information as used by"]
    #[doc = " most of the other time related functions. This allows the"]
    #[doc = " caller to map between frame counts and microseconds with full"]
    #[doc = " precision (i.e. without rounding frame times to integers),"]
    #[doc = " and also provides e.g. the microseconds time of the start of"]
    #[doc = " the current cycle directly (it has to be computed otherwise)."]
    #[doc = ""]
    #[doc = " If the return value is zero, the following information is"]
    #[doc = " provided in the variables pointed to by the arguments:"]
    #[doc = ""]
    #[doc = " current_frames: the frame time counter at the start of the"]
    #[doc = "                 current cycle, same as jack_last_frame_time()."]
    #[doc = " current_usecs:  the microseconds time at the start of the"]
    #[doc = "                 current cycle."]
    #[doc = " next_usecs:     the microseconds time of the start of the next"]
    #[doc = "                 next cycle as computed by the DLL."]
    #[doc = " period_usecs:   the current best estimate of the period time in"]
    #[doc = "                  microseconds."]
    #[doc = ""]
    #[doc = " NOTES:"]
    #[doc = ""]
    #[doc = " Because of the types used, all the returned values except period_usecs"]
    #[doc = " are unsigned. In computations mapping between frames and microseconds"]
    #[doc = " *signed* differences are required. The easiest way is to compute those"]
    #[doc = " separately and assign them to the appropriate signed variables,"]
    #[doc = " int32_t for frames and int64_t for usecs. See the implementation of"]
    #[doc = " jack_frames_to_time() and Jack_time_to_frames() for an example."]
    #[doc = ""]
    #[doc = " Unless there was an xrun, skipped cycles, or the current cycle is the"]
    #[doc = " first after freewheeling or starting Jack, the value of current_usecs"]
    #[doc = " will always be the value of next_usecs of the previous cycle."]
    #[doc = ""]
    #[doc = " The value of period_usecs will in general NOT be exactly equal to"]
    #[doc = " the difference of next_usecs and current_usecs. This is because to"]
    #[doc = " ensure stability of the DLL and continuity of the mapping, a fraction"]
    #[doc = " of the loop error must be included in next_usecs. For an accurate"]
    #[doc = " mapping between frames and microseconds, the difference of next_usecs"]
    #[doc = " and current_usecs should be used, and not period_usecs."]
    #[doc = ""]
    #[doc = " @return zero if OK, non-zero otherwise."]
    #[link_name = "\u{1}_jack_get_cycle_times"]
    pub fn jack_get_cycle_times(
        client: *const jack_client_t,
        current_frames: *mut jack_nframes_t,
        current_usecs: *mut jack_time_t,
        next_usecs: *mut jack_time_t,
        period_usecs: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the estimated time in microseconds of the specified frame time"]
    #[link_name = "\u{1}_jack_frames_to_time"]
    pub fn jack_frames_to_time(client: *const jack_client_t, arg1: jack_nframes_t) -> jack_time_t;
}
extern "C" {
    #[doc = " @return the estimated time in frames for the specified system time."]
    #[link_name = "\u{1}_jack_time_to_frames"]
    pub fn jack_time_to_frames(client: *const jack_client_t, arg1: jack_time_t) -> jack_nframes_t;
}
extern "C" {
    #[doc = " @return return JACK\'s current system time in microseconds,"]
    #[doc = "         using the JACK clock source."]
    #[doc = ""]
    #[doc = " The value returned is guaranteed to be monotonic, but not linear."]
    #[link_name = "\u{1}_jack_get_time"]
    pub fn jack_get_time() -> jack_time_t;
}
extern "C" {
    #[link_name = "\u{1}_jack_error_callback"]
    pub static mut jack_error_callback:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
}
extern "C" {
    #[doc = " Set the @ref jack_error_callback for error message display."]
    #[doc = " Set it to NULL to restore default_jack_error_callback function."]
    #[doc = ""]
    #[doc = " The JACK library provides two built-in callbacks for this purpose:"]
    #[doc = " default_jack_error_callback() and silent_jack_error_callback()."]
    #[link_name = "\u{1}_jack_set_error_function"]
    pub fn jack_set_error_function(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
extern "C" {
    #[link_name = "\u{1}_jack_info_callback"]
    pub static mut jack_info_callback:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
}
extern "C" {
    #[doc = " Set the @ref jack_info_callback for info message display."]
    #[doc = " Set it to NULL to restore default_jack_info_callback function."]
    #[doc = ""]
    #[doc = " The JACK library provides two built-in callbacks for this purpose:"]
    #[doc = " default_jack_info_callback() and silent_jack_info_callback()."]
    #[link_name = "\u{1}_jack_set_info_function"]
    pub fn jack_set_info_function(
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
extern "C" {
    #[doc = " The free function to be used on memory returned by jack_port_get_connections,"]
    #[doc = " jack_port_get_all_connections, jack_get_ports and jack_get_internal_client_name functions."]
    #[doc = " This is MANDATORY on Windows when otherwise all nasty runtime version related crashes can occur."]
    #[doc = " Developers are strongly encouraged to use this function instead of the standard \"free\" function in new code."]
    #[doc = ""]
    #[doc = " @param ptr the memory pointer to be deallocated."]
    #[link_name = "\u{1}_jack_free"]
    pub fn jack_free(ptr: *mut ::std::os::raw::c_void);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
